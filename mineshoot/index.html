<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="shortcut icon" href="TemplateData/favicon.ico">
    <link rel="stylesheet" href="TemplateData/style.css">
  </head>
  <body class="dark">
    <div id="unity-container" class="unity-desktop">
      <canvas id="unity-canvas"></canvas>
    </div>
    <div id="loading-cover" style="display:none;">
      <div id="unity-loading-bar">
        <div id="unity-logo"><img src="logo.png"></div>
        <div id="unity-progress-bar-empty" style="display: none;">
          <div id="unity-progress-bar-full"></div>
        </div>
        <div class="spinner"></div>
      </div>
    </div>
    <div id="unity-fullscreen-button" style="display: none;"></div>
    <script>
      window.mergedBlobUrls = {};
      window.assetsReady = false;

      async function mergeSplitFile(fileUrlBase, numParts = 2) {
        const partUrls = Array.from({ length: numParts }, (_, i) => 
          `${fileUrlBase}.part${i + 1}`
        );

        try {
          const responses = await Promise.all(
            partUrls.map(url => fetch(url))
          );

          if (responses.some(r => !r.ok)) {
            return null;
          }

          const parts = await Promise.all(
            responses.map(r => r.arrayBuffer())
          );

          const combinedBlob = new Blob(parts, {
            type: 'application/octet-stream'
          });

          return URL.createObjectURL(combinedBlob);
        } catch (error) {
          return null;
        }
      }

      function setupXHRInterceptor() {
        if (window.xhrInterceptorInstalled) {
          return;
        }
        
        const originalOpen = XMLHttpRequest.prototype.open;
        const originalSend = XMLHttpRequest.prototype.send;

        XMLHttpRequest.prototype.open = function(method, url, ...args) {
          this._url = url;
          this._method = method;
          this._args = args;
          
          let finalUrl = url;
          const decodedUrl = decodeURIComponent(url);
          
          for (const [filename, blobUrl] of Object.entries(window.mergedBlobUrls)) {
            if (url.includes(encodeURIComponent(filename)) || 
                decodedUrl.includes(filename) || 
                url.includes(filename)) {
              finalUrl = blobUrl;
              break;
            }
          }
          
          return originalOpen.call(this, method, finalUrl, ...args);
        };

        XMLHttpRequest.prototype.send = function(...args) {
          const xhr = this;
          
          if (!window.assetsReady) {
            const checkReady = setInterval(() => {
              if (window.assetsReady) {
                clearInterval(checkReady);
                originalSend.apply(xhr, args);
              }
            }, 50);
            return;
          }
          
          return originalSend.apply(this, args);
        };
        
        window.xhrInterceptorInstalled = true;
      }

      function setupFetchInterceptor() {
        if (window.fetchInterceptorInstalled) {
          return;
        }

        const originalFetch = window.fetch;
        window.fetch = function(url, ...args) {
          let finalUrl = url;
          const decodedUrl = typeof url === 'string' ? decodeURIComponent(url) : '';
          
          for (const [filename, blobUrl] of Object.entries(window.mergedBlobUrls)) {
            if ((typeof url === 'string' && 
                (url.includes(encodeURIComponent(filename)) || 
                 decodedUrl.includes(filename) || 
                 url.includes(filename)))) {
              finalUrl = blobUrl;
              break;
            }
          }
          
          return originalFetch.call(this, finalUrl, ...args);
        };

        window.fetchInterceptorInstalled = true;
      }

      async function prepareGameAssets() {
        try {
          window.assetsReady = false;
          delete window.xhrInterceptorInstalled;
          delete window.fetchInterceptorInstalled;
          window.mergedBlobUrls = {};
          
          setupXHRInterceptor();
          setupFetchInterceptor();
          
          const filesToMerge = [
            'Build/MineShooter_GD.data.unityweb'
          ];
          
          for (const filename of filesToMerge) {
            const blobUrl = await mergeSplitFile(filename, 2);
            if (blobUrl) {
              window.mergedBlobUrls[filename] = blobUrl;
            }
          }
          
          window.assetsPrepared = true;
          window.assetsReady = true;
          
        } catch (error) {
          window.assetsPrepared = false;
          window.assetsReady = true;
        }
      }

      prepareGameAssets().then(() => {
        initUnity();
      });

      function initUnity() {
        const hideFullScreenButton = "1";
        const buildUrl = "Build";
        const loaderUrl = buildUrl + "/MineShooter_GD.loader-edit.js";
        const config = {
          dataUrl: buildUrl + "/MineShooter_GD.data.unityweb",
          frameworkUrl: buildUrl + "/MineShooter_GD.framework.js.unityweb",
          codeUrl: buildUrl + "/MineShooter_GD.wasm.unityweb",
          streamingAssetsUrl: "StreamingAssets",
          companyName: "GoGoMan",
          productName: "Minecraft Shooter",
          productVersion: "0.1",
        };

        const container = document.querySelector("#unity-container");
        const canvas = document.querySelector("#unity-canvas");
        const loadingCover = document.querySelector("#loading-cover");
        const progressBarEmpty = document.querySelector("#unity-progress-bar-empty");
        const progressBarFull = document.querySelector("#unity-progress-bar-full");
        const fullscreenButton = document.querySelector("#unity-fullscreen-button");
        const spinner = document.querySelector('.spinner');

        const canFullscreen = (function() {
          for (const key of [
              'exitFullscreen',
              'webkitExitFullscreen',
              'webkitCancelFullScreen',
              'mozCancelFullScreen',
              'msExitFullscreen',
            ]) {
            if (key in document) {
              return true;
            }
          }
          return false;
        }());

        if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
          container.className = "unity-mobile";
          config.devicePixelRatio = 1;
        }
        canvas.style.background = "url('" + buildUrl + "/MineShooter_GD.jpg') center / cover";
        loadingCover.style.display = "";

        const script = document.createElement("script");
        script.src = loaderUrl;
        script.onload = () => {
          createUnityInstance(canvas, config, (progress) => {
            spinner.style.display = "none";
            progressBarEmpty.style.display = "";
            progressBarFull.style.width = `${100 * progress}%`;
          }).then((unityInstance) => {
            loadingCover.style.display = "none";
            if (canFullscreen) {
              if (!hideFullScreenButton) {
                fullscreenButton.style.display = "";
              }
              fullscreenButton.onclick = () => {
                unityInstance.SetFullscreen(1);
              };
            }
          }).catch((message) => {
            alert(message);
          });
        };
        document.body.appendChild(script);
      }
    </script>
  </body>
</html>